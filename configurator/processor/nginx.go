package processor

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/acheraime/gozouti/utils"
)

type NginxRedirect struct {
	in        [][]string
	outDir    string
	resources []resource
	buffer    bytes.Buffer
	dupes     []map[string]string
	parseURL  bool
}

type resource struct {
	redirectFrom string
	redirectTo   string
}

var (
	checkBucket = map[string]string{}
	fileHeader  = "#### This file is automatically generated by certutils CLI tool ####\n"
)

func NewNginxRedirect(input [][]string, outputDir string, withHost bool) (Processor, error) {
	if input == nil {
		return nil, fmt.Errorf("no input to process")
	}

	if err := utils.CheckDir(outputDir); err != nil {
		return nil, err
	}

	redirect := NginxRedirect{
		in:       input,
		outDir:   outputDir,
		parseURL: withHost,
	}

	var res = make([]resource, len(input))
	var dupes = []map[string]string{}
	for i, row := range input {
		rFrom := strings.Trim(row[0], " ")
		rTo := strings.Trim(row[1], " ")

		if rFrom == "" || rFrom == "/" {
			// We cannot redirect from /
			continue
		}

		// Check dupe
		if utils.KeyExists(rFrom, checkBucket) {
			dupes = append(dupes, map[string]string{
				"originResource":      rFrom,
				"destinationResource": rTo,
				"rowNumber":           strconv.Itoa(i + 1),
			})

			continue
		}
		checkBucket[rFrom] = rTo

		// A full url is provided
		// parse it to extract the
		// resource paths
		if redirect.parseURL {
			furl, err := utils.ParseURL(rFrom)
			if err != nil {
				fmt.Println("unable to parse " + rFrom)
				continue
			}
			rFrom = furl.Path
			turl, err := utils.ParseURL(rTo)
			if err != nil {
				fmt.Println("unable to parse " + rTo)
				continue
			}
			rTo = turl.Path
		}

		rFrom = utils.AddSlash(rFrom)
		rTo = utils.AddSlash(rTo)

		res = append(res, resource{redirectFrom: rFrom, redirectTo: rTo})
	}

	redirect.resources = res

	if len(dupes) > 0 {
		redirect.dupes = dupes
	}

	return redirect, nil
}

// DryRun runs sanity checks and generate
// a report. It can optionally dump the redirect
// file that will be generated to stdout.
func (r NginxRedirect) DryRun(reportDir string) error {
	fmt.Println("======================================")
	fmt.Printf("Proceeded: %d rows\n", len(r.resources))
	fmt.Printf("Found %d duplicates\n", len(r.dupes))

	if err := utils.CheckDir(reportDir); err != nil {
		return err
	}

	// Create the full file path
	reportFile := filepath.Join(reportDir, "dryrun-report.csv")
	if len(r.dupes) > 0 {
		// Write dupes to a file
		records := [][]string{
			[]string{"Row Number", "From Resource", "To Resource"},
		}
		for _, d := range r.dupes {
			//fmt.Printf("[%s] %s -> %s\n", d["rowNumber"], d["originResource"], d["destinationResource"])
			records = append(records, []string{d["rowNumber"], d["originResource"], d["destinationResource"]})
		}
		file, err := os.OpenFile(reportFile, os.O_RDWR|os.O_CREATE, 0640)
		if err != nil {
			return err
		}
		defer file.Close()

		w := csv.NewWriter(file)
		w.WriteAll(records)
		if err := w.Error(); err != nil {
			return err
		}
	}

	fmt.Printf("Duplicate report is written to: %s\n", reportFile)
	return r.build(os.Stdout)
}

func (r *NginxRedirect) build(o io.Writer) error {
	if r.resources == nil {
		return fmt.Errorf("nothing to generate: %s", r.resources)
	}

	// reset the buffer
	r.buffer.Reset()
	fileHeader += fmt.Sprintf("#### Timestamp: %s\n", time.Now().Format(time.RFC1123))
	r.buffer.Write([]byte(fileHeader + "\n\n"))

	for _, resource := range r.resources {
		if resource.redirectFrom == "" {
			continue
		}
		str := fmt.Sprintf(
			`location ~^%s?$ {
	return 301 https://$host%s;
}`, resource.redirectFrom, resource.redirectTo)
		r.buffer.Write([]byte(str + "\n\n"))
	}
	// WriteTo implicitly call
	// flush
	r.buffer.WriteTo(o)

	return nil
}

func (r NginxRedirect) Generate() error {
	if err := utils.CheckDir(r.outDir); err != nil {
		return err
	}

	// Default file name
	fileName := fmt.Sprintf("generated-%s.conf", time.Now().Format("20060102150405"))
	outPath := filepath.Join(r.outDir, fileName)
	f, err := os.OpenFile(outPath, os.O_RDWR|os.O_CREATE, 0640)
	if err != nil {
		return err
	}
	defer f.Close()

	return r.build(f)
}
